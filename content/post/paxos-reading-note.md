---
title: "[总结] 分布式理论 -《从Paxos到Zookeeper 分布式一致性原理与实践》"
date: 2020-10-04T22:06:00+08:00
draft: false
---

本文为《从Paxos到Zookeeper 分布式一致性原理与实践》的读书笔记

# 1 分布式名词概念解析
## 1.1 脑裂
在HA集群系统中，假设有同一个整体、动作协调的节点A 和节点B，节点A和B之间通过heartBeat来检查对方的存活状态,负责协调保证整个集群服务的可用性。正常情况下，如果节点A通过心跳检测不到B的存在的时候，就会接管B的资源，同理节点B检查不到B的存活状态的时候也会接管A的资源。

如果出现网络故障，就会导致A和B同时检查不到对方的存活状态认为对方出现异常，这个时候就会导致A接管B的资源，B也会接管A的资源。原来被一个节点访问的资源就会出现被多个节点同时访问的情况，这种情况就是脑裂现象。

嗯，这是比较官方的解释，说人话的话，其实就是在一个集群中，有多个“大脑”，即多个master

## 1.2 三态
在传统的单机系统中，我们调用一个函数，这个函数要么返回成功，要么返回失败，其结果是确定的。可以概括为传统的单机系统调用只存在两态（2-state system）：成功和失败。

然而在分布式系统中，由于系统是分布在不同的机器上，系统之间的请求就相对于单机模式来说复杂度较高了。具体的，节点 A 上的系统通过 RPC (Remote Procedure Call) 方式与节点 B 上的系统进行通信，在这个请求结果存在三态(3-state system)：也就是成功、失败和超时，不要小瞧超时这个状态，因为它几乎是所有分布式系统复杂性的根源。

# 2 ACID
事务具有四个属性：

- Atomic（原子性）

    事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，要么全部执行，要么全部不执行。

    任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚。只有所有的操作全部成功，整个事务才算是成功完成。

- Consistency（一致性）
    事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行前后，数据库都必须处于一致性状态。换句话说，事务的执行结果必须是使数据库从一个一致性状态转变到另一个一致性状态。

    假设银行的转账操作就是一个事务。假设A和B原来账户都有100元。此时A转账给B50元，转账结束后，应该是A账户减去50元变成50元，B账户增加50元变成150元。A、B的账户总和还是200元。转账前后，数据库就是从一个一致性状态（A100元，B100元，A、B共200元）转变到另一个一致性状态（A50元，B150元，A、B共200元）。假设转账结束后只扣了A账户，没有增加B账户，这时数据库就处于不一致的状态。

- Isolation（隔离性）
    事务的隔离性是指在并发环境中，并发的事务是相互隔离的，事务之间互不干扰。

    在标准的SQL规范中，定义的4个事务隔离级别，不同隔离级别对事务的处理不同。4个隔离级别分别是：读未提交、读已提交、可重复读和串行化。 

    事务隔离级别越高，就越能保证数据的完整性和一致性，但同时对并发性能的影响也越大。

    通常，对于绝大多数的应用来说，可以优先考虑将数据库系统的隔离级别设置为授权读取，这能够在避免脏读的同时保证较好的并发性能。尽管这种事务隔离级别会导致不可重复读、幻读和第二类丢失更新等并发问题，但较为科学的做法是在可能出现这类问题的个别场合中，由应用程序主动采用悲观锁或乐观锁来进行事务控制。

- Durability（持久性）

    事务的持久性又称为永久性，是指一个事务一旦提交，对数据库中对应数据的状态变更就应该是永久性的。即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。
# 3 分布式事务
事务在分布式计算领域也得到了广泛的应用。在单机数据库中，我们很容易能够实现一套满足ACID特性的事务处理系统，但是在分布式数据库中，数据分散在各台不同的机器上，如何对这些数据进行分布式事务处理具有非常大的挑战。

分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。通常一个分布式事务会涉及对多个数据源或业务系统的操作。

举个例子来说明分布式事务。一个最典型的分布式事务场景是跨行的转账操作。该操作涉及调用两个异地的银行服务。其中一个是本地银行提供的取款服务，另一个是目标银行提供的存款服务，这两个服务本身是无状态且相互独立的，共同构成了一个完整的分布式事务。取款和存款两个步骤要么都执行，要么都不执行。否则，如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么必须回滚到取款之前的状态，否则就会导致数据不一致。

从上面的例子可以看出，一个分布式事务可以看作是由多个分布式操作序列组成的，例如上面例子中的取款服务和存款服务，通常可以把这一系列分布式的操作序列称为子事务。由于分布式事务中，各个子事务的执行是分布式的，因此要实现一种能够保证ACID特性的分布式事务处理系统就显得格外复杂。

# 4 CAP理论
集中式事务处理系统可以轻易做到满足ACID，但对于分布式事务处理系统，我们则可能会在可用性和严格一致性上出现冲突，而可用性和一致性又是分布式系统的刚需，那么如何来实现兼顾此二者的分布式系统成了讨论的难题，由此诞生了CAP理论。

## 4.1 CAP定理
一个分布式系统不可能同时满足一致性（C:Consistency）、可用性（A:Availability）和分区容错性（P:Partition tolerance）这三个基本要求，最多只能满足其中的两项。

- 一致性

    在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性（这点跟ACID中的一致性含义不同）。
对于一个将数据副本分布在不同节点上的分布式系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是更新前的数据（称为脏数据），这就是典型的分布式数据不一致情况。
在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都能读取到最新的值，那么这样的系统就被认为具有强一致性（或严格的一致性）。
可用性

- 可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果，如果超过了这个时间范围，那么系统就被认为是不可用的。

『有限的时间内』是一个在系统设计之初就设定好的运行指标，不同的系统会有很大的差别。比如对于一个在线搜索引擎来说，通常在0.5秒内需要给出用户搜索关键词对应的检索结果。而对应Hive来说，一次正常的查询时间可能在20秒到30秒之间。

『返回结果』是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出对请求的处理结果，及成功或失败，而不是一个让用户感到困惑的返回结果。

让我们再来看看上面提到的在线搜索引擎的例子，如果用户输入指定的搜索关键词后，返回的结果是一个系统错误，比如"OutOfMemoryErroe"或"System Has Crashed"等提示语，那么我们认为此时系统是不可用的。

- 分区容错性
    分区容错性要求一个分布式系统需要具备如下特性：分布式系统在遇到任何网络分区故障的时候，仍然能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

    网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络等）中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。

# 5 BASE理论
BASE是Basically Available(基本可用）、Soft state(软状态）和Eventually consistent(最终一致性）三个短语的简写。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方法来使系统达到最终一致性。

- 基本可用
基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。比如
响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。
功能上的损失：正常情况下，在一个电子商务网站（比如淘宝）上购物，消费者几乎能够顺利地完成每一笔订单。但在一些节日大促购物高峰的时候（比如双十一、双十二），由于消费者的购物行为激增，为了保护系统的稳定性（或者保证一致性），部分消费者可能会被引导到一个降级页面
- 弱状态
弱状态是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同的数据副本之间进行数据同步的过程存在延时。
- 最终一致性
最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。
- 因果一致性(Causal consistency)
如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问遵守一般的最终一致性规则。
读己之所写(Read your writes)
当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。
- 会话一致性(Session consistency)
这是上一个模型的实用版本，它把访问存储系统的进程放到会话的上下文中。只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统的保证不会延续到新的会话。
- 单调读一致性(Monotonic read consistency)
如果某个进程已经看到过数据对象的某个值，那么该进程任何后续访问都不会返回在那个值之前的值。
- 单调写一致性(Monotonic write consistency)
系统保证来自同一个进程的写操作顺序执行。要是系统不能保证这种程度的一致性，就非常难以编程了。

以上就是最终一致性的五种常见的变种，在实际系统实践中，可以将其中的若干个变种互相结合起来，以构建一个具有最终一致性特性的分布式系统。

事实上，最终一致性并不是只有那些大型分布式系统才涉及的特性，许多现代的关系型数据库都采用了最终一致性模型。在现代关系型数据库中（比如MySQL和PostgreSQL），大多都会采用同步或异步方式来实现主备数据复制技术。在同步方式中，数据的复制过程通常是更新事务的一部分，因此在事务完成后，主备数据库的数据就会达到一致。而在异步方式中，备库的更新往往会存在延时，这取决于事务日志在主备数据库之间传输的时间长短。


# 6 2PC 和 3PC协议
分布式系统架构设计中往往是在系统可用性和数据一致性之间进行反复权衡，于是产生了系列一致性协议。

在分布式系统中，每个节点都能明确知道自身事务操作结果，但无法直接获取到其他分布式节点的操作结果。所以当一个事务要横跨多个节点时，为了保证事务处理的ACID特性而引入了协调者组件来统一调度所有分布式节点（参与者）的执行逻辑，协调者调度参与者的行为并最终决定是否把参与者的事务进行真正的提交

## 6.1 2PC
### 6.1.1 简介
2PC（Two-Phase Commit 两阶段提交）：完成参与者的协调，统一决定事务的提交或回滚，使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和数据一致性。
目前绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的。
### 6.1.2 协议内容
1. 投票，尝试让协调者们提交事务
    - 事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，等待响应
   - 执行事务：参与者节点执行事务操作，并记录Undo和Redo信息到事务日志
   - 参与者响应：若参与者成功执行事务，则向协调者反馈Yes响应，否则反馈No响应
2. 根据协调者反馈决定事务执行结果 21. 如果所有参与者的反馈都是Yes响应，那么执行事务提交 - 发送提交请求：协调者向所有参与者发送Commit请求 - 事务提交：参与者接受到Commit请求后执行事务提交操作并释放占用的事务资源 - 反馈事务提交结果：参与者完成事务提交后向协调者发送Ack消息 - 完成事务：协调者收到所有参与者的Ack响应后，完成事务提交

3 如果任何一个参与者返回了N响应或者协调者等待超时后就会中断事务
   - 发送回滚请求：协调者向所有参与者发送Rollback请求
   - 事务回滚：参与者受到请求后通过Undo信息执行事务回滚操作并释放占用的事务资源
   - 反馈事务回滚结果：参与者回滚事务后向协调者发送Ack消息
   - 中断事务：协调者接收到所有参与者的Ack响应后，完成事务中断

### 6.1.3 优缺点
优点 : 原理简单，实现方便

缺点 :

    - 同步阻塞：在阶段二事务提交过程中，所有参与者的操作逻辑都处于阻塞状态，等待其他参与者响应，协调者请求
    - 单点问题：一旦协调者出现问题，阶段二提交流程无法运转，并且参与者会一直处于锁定事务资源的状态，无法继续事务操作
    - 数据不一致：当协调者向所有参与者发送了Commit请求后局部网络异常或协调者半路出错导致只有部分参与者收到Commit请求，造成系统出现数据不一致
    - 太过保守：任何一个参与节点的失败使得协调者无法获取所有参与者的响应信息都会导致整个事务的失败
## 6.2 3PC
### 6.2.1 简介
3PC（Three-Phase Commit 三阶段提交）将二阶段提交的提交事务请求过程一分为二，形成CanCommit、PreCommit、doCommit三个阶段

### 6.2.2 内容
1. CanCommit
   - 事务询问：协调者向所有参与者发送包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，等待响应
   - 参与者响应：参与者接收到CanCommit请求后判断自身能够顺利执行事务，能则返回Yes响应并进入预备状态，否则返回No响应
2. PreCommit 
      1. 如果所有参与者反馈都为Yes响应，则执行事务预提交 - 发送预提交请求：协调者向所有参与者节点发出PreCommit请求，并进入  - Prepared阶段 - 事务预提交：参与者接收到PreCommit请求后预执行事务操作（还未提交），并记录Undo和Redo信息到事务日志中 - 参与者响应事务执行结果：若参与者成功执行事务后则返回Ack响应给协调者，等待最终命令，提交（commit）或者中断（abort） 
   
      2.  如果任何一个参与者反馈了No响应或者协调者等待所有协调者的响应超时则中断事务 - 发送中断请求：协调者向所有参与者节点发出Abort请求 - 中断事务：无论收到Abort请求或者等待协调者请求超时，参与者都会中断事务
   
3. 执行提交 
   
   - 发送提交请求：当协调者收到所有参与者反馈的Ack响应，向所有参与者发送DoCommit请求，从预提交状态转到提交状态 
   - 事务提交：参与者接收到DoCommit请求后，正式执行事务提交操作，并释放占用的事务资源 
   - 反馈事务提交结果：参与者完成事务提交后向协调者发送Ack消息 
   - 完成事务：协调者接受到所有参与者反馈的Ack响应后，完成事务 
   - 中断事务 
     - 发送中断请求：协调者向所有参与者节点发出Abort请求 
     - 事务回滚：参与者接收到Abort请求后，利用Undo信息执行事务回滚操作，并释放占用的事务资源 
     - 反馈事务回滚结果：参与者完成事务回滚后向协调者发送Ack消息 
     - 中断事务：协调者接收到所有参与者反馈的Ack响应后，中断事务

### 6.2.3 优缺点
优点:降低参与者的阻塞范围，能够在出现单点故障后继续达成一致

缺点:接受者接收到PreCommit消息后，如果出现网络分区导致协调者和参与者无法正常通信，这时参与者仍会进行事务提交，造成数据的不一致

# 7 paxos算法
Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。
  
Paxos算法及变种算法在分布式系统中应用广泛。基于Paxos算法的变种有：ZAB、Raft。 Zookeeper 中的ZAB协议也是Paxos算法的变种。

Paxos是一个解决共识问题consensus problem的算法，现实中Paxos的实现以及成为一些世界级软件的心脏，如Cassandra, Google的Spanner数据库, 分布式锁服务Chubby。一个被Paxos管理的系统实际上谈论的是值状态和跟踪等问题，其目标是建造更高可用性和强一致性的分布式系统。

Paxos算法解决的问题是在一个可能发生消息可能会延迟、丢失、重复的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。这 个“值”可能是一个数据的某，也可能是一条log日志等；根据不同的应用环境这个“值”也不同。

## 7.1 角色
Paxos中有三类角色Proposer、Acceptor及Learner，主要交互过程在Proposer和Acceptor之间。网络中的任意节点，都可能既是Proposer，又是Acceptor。
当某个节点想将分布式系统中进行写操作的，它就是Proposer。除Proposer外，所有接收到请求，被要求对某个值进行更改的其他节点，就是Acceptor。
## 7.2 比喻推导前提
- 举个例子，一个城市为了确定城市未来的发展方针，市长皮皮虾决定集思广益，向全体市民寻求建议。每个人都有建议权，也都有投票权（一个市民在发展方针的时候，他就是proposer，其他人是acceptor，此时，发展方针即表示节点希望推动的值变更或者说值状态，他希望所有节点都接受自己提出的值变更）

- 在现实环境中我们可以在一个大会堂召集全体市民共同讨论或在微信群中讨论（基于内存共享方式）；但在基于消息传递的分布式环境中每个人只能通过手机短信与其它人沟通。我们要寻求一种机制以解决如何在这种会延迟、丢失的环境中确定一个城市的发展方针。

在讨论之前，我们得制定一些投票规则，以便能够胜利选出呼声最高的发展方针。

1. 最终只能确定一个建议
2. 少数服从多数。只要建议被多数人同意即可确定该建议。

为了保证投票环节让所有人信服，我们得保证如下几点：

1. 只有被提出来的建议才能被大家投票同意。也就是大家只能投票给被建议出来的选项。
2. 最终一定要能够得到一个被大多数人同意的建议。
3. 不同人的提议可以重复。
4. 如果某个人认为大家同意了某个建议，那么这个建议必须真的是被大家同意的。
也就是要让所有市民心服口服，人们认为的众望所归的建议，必须真的是大家众望所归的建议。
## 7.3 比喻推导过程
为了制定行之有效的机制，市长皮皮虾召集了一大批专家团队来规划整个决策机制，在讨论当中，专家们提出了许多未来可能遇到的问题，并尝试完善规则：

7.3.1 情况一
如果因为宣传不充分，很多人准备也不到位，结果只有一位市民提出了自己的建议，它希望这个小城大力发展纸尿裤行业，希望大家在即将到来的投票中选择自己的提议。这个明显是帮宝适董事长提的傻逼建议，在初步征询阶段就得不到市民的认可，于是情况陷入了僵局，在没有新的建议出来的情况下，大家都不同意，导致决策机制彻底失灵。

解决办法：为了使得这个表决机制不会陷入这个局面，一根筋的市长皮皮虾决定增加一条硬性规定，我们称他为P1：不许不投票，每一个人必须同意他收到的第一个建议。这样即使只有一个建议被提出，也能够被采纳。

### 7.3.2 情况二
此时一位专家说：基于情况一，我们要求每一个人必须同意他收到的第一个提议，但因为我们又需要一个提议必须被大多数人同意才能生效，所以一个人必须可以同时同意多个人的建议，即一个人必须可以拥有多次投票权可以投给不同的人，不然发生A同意B，B同意C，C同意D，D同意A的情况，永远也得不出一个超过半数同意的提议。

但这时又有一位专家提醒，就算我们允许一个人可以投给不同的人，也会遇到类似的僵局，比如A同意B和C的提议，B同意C和D的提议，C同意D和A的提议，D同意A和B的提议，这样每个人的提议都有两票，也会陷入僵局。

要避免出现这种问题，就要求被某个人投票的这些建议者们，他们的提议内容都是一样的。

于是市长规定，我们称他为P2：市民只能有一个立场，抱定这个立场后，可以投票给不同的但都是提议该立场的建议者，以便选出最后得票最高的建议。

### 7.3.3 情况三
此时一位专家说：如果有五个人甲乙丙丁戊，甲乙丙三个人同意了方案A，方案A成为了主流意见。丁，戊 2人由于之前手机没电，没收到通知，所以他们下线了。当他们2人开机后（注意此时甲乙丙之间的投票已经结束，方案A成为了主流意见），丁和戊以为主流意见尚未选出，刚好丁也有提议没发出去，所以丁给戊发短信提议了方案B，这个提议是戊开机后第一次收到的提议，根据P1原则，他必须同意他接收到的第一个提议，并将其作为自己的立场，所以戊同意方案B。但这样就会导致戊与甲乙丙他们意见不一致。

一个人意见不一致还好，但因为有这样的漏洞，所以可能最后和主流意见不一致的人会非常多，这不利于我们构建和谐且令人心服的讨论。

于是市长皮皮虾对P2进行了补充，我们称为P2a:一旦一个提议成为了主流的意见，那么之后的人再次投票的提议内容，必须和主流意见内容一致。

也就是说，戊在开机后同意的第一个提议必须是方案A才不会出现信息不一致的现象。但戊开机后必须得接受第一个提议（P1原则），并且无法干涉提议中的内容（方案A还是方案B）。所以最好的办法通过某种方式让丁的提议中的内容与甲乙丙的提议相同。这样戊同意的第一个提议就是方案A

于是皮皮虾再次对P2a进行补充，我们称为P2b:一旦一个提议成为主流意见，那么之后的人再次提议，提议中的内容必须跟主流意见一致。

如何让刚开机的戊提议的内容必须与甲乙丙同意的一致呢？要想达到这一点，只要达到另一个条件即可：

我们称为P2c:存在一个提议A，对于大多数市民来说，要么他们中所有人在同意A前没有同意其他提议，要么他们已经同意的所有提议，内容都和A一模一样。

如果能做到P2c这一点，那么P2b自然就达到了，P2c是P2b的充分条件。也是P2的充分条件。

## 7.4 paxos流程比喻
也就是说，要想这个表决机制表决出的结果是真的所有人都认同的，那么必须同时满足P1,P2c(P2的充分条件),那如何设计表决的程序，才能使表决满足P1和P2c呢？

而且P2c条件中，有提议的时间先后概念，在一个只能依靠短信沟通的环境中，如何确定一个提议早于另外一个提议被提出呢？毕竟就算某个提议A比提议B早提出，它也不可能永远比B早到达每一个节点。众人觉得应该引入一个全局的编号，每个提议对应一个编号，用这个编号来表示时间维度的早和晚。但具体如何实施呢？

在众人一筹莫展的时候，一个天才专家站了出来，它设计了一个流程，能够使P1和P2c成立。

专家建议，谁的提议最后被选为了最终提议，可以奖励一个巨量的奖金，这样，每一个提议者都会竭尽所能的让自己的提议成为最终提议（模拟真实paxos实现中proposer始终试图让acceptor接受自己提议的场景）

专家还建议，可以引入贿选机制，每个提议者都可以为自己的提议选定一个贿选金额（模拟实际情况中的全局编号），承诺如果自己的提议成为最终提议，每个接受自己的提议的投票人可以得到该金额。贿选金额维护在一个地方，每个提议者在提议之前都知道目前最高的贿选金额是多少了。

为了得到最后的奖金，每个提议者都会一直提高这个贿选金额（这就模拟了实际中一直自增的全局编号，也合理了为什么accept会投票给后来的提议，因为后来的提议给的钱多啊）。

基于上面两个前提，专家提出了最后的流程，这个表决要分两步：

准备阶段，大家先内部讨论一下，不急着投票

    1. proposer选择一个贿选金额，并将信息以 `[贿选金额，提议内容]`的kv形式广播（prepare请求）。
   
    2. 如果收信人收到 [贿选金额，提议内容] 后。
       
       - 如果该提议的金额大于它已经回复的所有提议的金额。那么acceptor将会为了钱出卖自己的上家，将自己上次接受的提议内容以及上家给了他多少钱回复给proposer，即[之前最高的贿选金额，我之前同意的提案内容]，并承诺不再接受小于这个金额的提议。
       - 如果该提议的金额不大于它已经接受的那个提议的金额。那么直接无视。（贿选金额没有吸引力，无视）
同意阶段，经过阶段一，proposer们已经通过acceptor们的反馈知道了每个acceptor的投票承诺。（因为prepare是广播形式，所以会受到全部acceptor的返回，即要么得到接受提议的回馈，表示我接受你的提案了，并且将我上家的提案告诉你。要么我就无视你，无视也是一种表态），

    1. 当proposer收到多数人接受提议的反馈信息后，就进入同意阶段（重点，收到大多数的承诺后才会进入同意阶段）。它要向反馈给它信息的人再次发送一个请同意该提议的请求（accept请求）,内容为 `[第一步的那个贿选金额，收到的反馈中价码最高的那个提议内容]`,（如果proposer接收到的所有回复中都没有acceptor已经接受过的提议内容，则proposer可以自由决定提议内容）
    
        注意，对于某些proposer来说，这里再次发出的提议内容，可能已经和自己之前在第一步的提议不一样了。因为如果他通过acceptor们的反馈（里面包含acceptor们接受的提议），知道了自己之前的提议没有成为主流意见，大伙大多数都同意了另一个给钱最壕的proposer的提议，那么为了彰显自己的正确，它也默默的把提议内容改成了大家都同意的提议内容。

    2. acceptor接收到请求：
       1. 在不违背向其它人承诺的前提下，收到该提议请求后会立即同意该请求，并回馈一个接受的消息。（即一个acceptor只要尚未响应过任何编号大于N的prepare请求，那么它就可以接受这个编号为N的accept请求）
       2. 而如果此时acceptor又叛变了，它接受了一个金额更高（编号更高）的提议，那么，他会无视这个accept请求。
   
如果一个proposer发出的accept请求没有得到大多数的回应，那么他就会知道大多数acceptor已经叛变了，无奈之下，他只能重新进入准备阶段，重新选择一个更大的金额（编号n），再去冲击一波。（此时他的提案，就是之前他默默改成的大家都同意的提议）

否则，如果一个proposer发出的accept请求得到了大多数的回应，那么流程结束，该proposer的提案胜出，至于算法如何将胜出的提案通知给 Learner，有如下三种方案，各有优劣

## 7.5 Learner学习被选定的value
Learner学习（获取）被选定的value有如下三种方案： 
![](https://gitee.com/ygmyth/blogimage/raw/master/20201004222102.png)

## 7.6 后述
Leslie Lamport没有用数学描述Paxos，但是他用英文阐述得很清晰。至于Paxos中一直提到的一个全局唯一且递增的proposer number，其如何实现，引用如下

如何产生唯一的编号呢？在《Paxos made simple》中提到的是让所有的Proposer都从不相交的数据集合中进行选择，例如系统有5个Proposer，则可为每一个Proposer分配一个标识j(0~4)，则每一个proposer每次提出决议的编号可以为5*i + j(i可以用来表示提出议案的次数)

除此之外，如何保证paxos的活性 
通过选取主Proposer，就可以保证Paxos算法的活性。至此，我们得到一个既能保证安全性，又能保证活性的分布式一致性算法——Paxos算法。